(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{188:function(e,t,n){"use strict";n.r(t),n.d(t,"MDXContext",(function(){return m})),n.d(t,"MDXProvider",(function(){return d})),n.d(t,"mdx",(function(){return g})),n.d(t,"useMDXComponents",(function(){return p})),n.d(t,"withMDXComponents",(function(){return u}));var a=n(0),r=n.n(a);function i(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function c(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?c(Object(n),!0).forEach((function(t){i(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):c(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var m=r.a.createContext({}),u=function(e){return function(t){var n=p(t.components);return r.a.createElement(e,o({},t,{components:n}))}},p=function(e){var t=r.a.useContext(m),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},d=function(e){var t=p(e.components);return r.a.createElement(m.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return r.a.createElement(r.a.Fragment,{},t)}},f=r.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,i=e.originalType,o=e.parentName,c=s(e,["components","mdxType","originalType","parentName"]),m=p(n),u=a,d=m["".concat(o,".").concat(u)]||m[u]||h[u]||i;return n?r.a.createElement(d,l(l({ref:t},c),{},{components:n})):r.a.createElement(d,l({ref:t},c))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var i=n.length,o=new Array(i);o[0]=f;var c={};for(var l in t)hasOwnProperty.call(t,l)&&(c[l]=t[l]);c.originalType=e,c.mdxType="string"==typeof e?e:a,o[1]=c;for(var s=2;s<i;s++)o[s]=n[s];return r.a.createElement.apply(null,o)}return r.a.createElement.apply(null,n)}f.displayName="MDXCreateElement"},50:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return c})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return m}));var a=n(3),r=n(8),i=(n(0),n(188)),o={sidebar_position:4,keywords:"weights, fees, runtime, FRAME v1"},c={unversionedId:"weights/calculate-fees",id:"weights/calculate-fees",isDocsHomePage:!1,title:"Calculating fees",description:"Learn how to calculate fees from within your runtime.",source:"@site/docs/03-weights/calculate-fees.md",sourceDirName:"03-weights",slug:"/weights/calculate-fees",permalink:"/substrate-how-to-guides/docs/weights/calculate-fees",editUrl:"https://github.com/substrate-developer-hub/substrate-how-to-guides/edit/main/docs/03-weights/calculate-fees.md",version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4,keywords:"weights, fees, runtime, FRAME v1"},sidebar:"tutorialSidebar",previous:{title:"Quadratic weighting struct",permalink:"/substrate-how-to-guides/docs/weights/quadratic-weight-struct"},next:{title:"Testing a transfer function",permalink:"/substrate-how-to-guides/docs/testing/test-transfer"}},l=[{value:"Goal",id:"goal",children:[]},{value:"Use cases",id:"use-cases",children:[]},{value:"Overview",id:"overview",children:[]},{value:"Steps",id:"steps",children:[{value:"1. Write the <code>LinearWeightToFee</code> struct",id:"1-write-the-linearweighttofee-struct",children:[]},{value:"2. Configure <code>pallet_transaction_payment</code> in your runtime",id:"2-configure-pallet_transaction_payment-in-your-runtime",children:[]}]},{value:"Examples",id:"examples",children:[]},{value:"Related material",id:"related-material",children:[]}],s={toc:l};function m(e){var t=e.components,n=Object(r.default)(e,["components"]);return Object(i.mdx)("wrapper",Object(a.default)({},s,n,{components:t,mdxType:"MDXLayout"}),Object(i.mdx)("p",null,Object(i.mdx)("em",{parentName:"p"},"Learn how to calculate fees from within your runtime.")),Object(i.mdx)("h2",{id:"goal"},"Goal"),Object(i.mdx)("p",null,"Customize ",Object(i.mdx)("inlineCode",{parentName:"p"},"WeightToFee")," to modify how fees are calculated for your runtime."),Object(i.mdx)("h2",{id:"use-cases"},"Use cases"),Object(i.mdx)("p",null,"Modify the way fees are calculated, instead of using ",Object(i.mdx)("a",{parentName:"p",href:"https://crates.parity.io/frame_support/weights/struct.IdentityFee.html"},Object(i.mdx)("inlineCode",{parentName:"a"},"IdentityFee"))," which maps one unit of fee to one unit of weight."),Object(i.mdx)("h2",{id:"overview"},"Overview"),Object(i.mdx)("p",null,"Fees are broken down into three components:"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("strong",{parentName:"li"},"Byte fee")," - A fee proportional to the transaction's length in bytes. The proportionality constant is a parameter in the transaction_payment pallet."),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("strong",{parentName:"li"},"Weight fee")," - A fee calculated from the transaction's weight. Weights quantify the time spent executing the transaction. Learn more in the recipe on weights. The conversion doesn't need to be linear, although it often is. The same conversion function is applied across all transactions from all pallets in the runtime."),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("strong",{parentName:"li"},"Fee Multiplier")," - A multiplier for the computed fee, that can change as the chain progresses.")),Object(i.mdx)("p",null,"FRAME provides the ",Object(i.mdx)("a",{parentName:"p",href:"https://github.com/paritytech/substrate/tree/master/frame/transaction-payment"},"transaction payment pallet")," for calculating and collecting fees for executing transactions. It\ncan be useful to modify the way fees are calculated to charge fees with more accuracy to your users. This guides steps through the process of customizing ",Object(i.mdx)("inlineCode",{parentName:"p"},"WeightToFee")," for your runtime's implementation of ",Object(i.mdx)("inlineCode",{parentName:"p"},"pallet_transaction_payment"),"."),Object(i.mdx)("h2",{id:"steps"},"Steps"),Object(i.mdx)("h3",{id:"1-write-the-linearweighttofee-struct"},"1. Write the ",Object(i.mdx)("inlineCode",{parentName:"h3"},"LinearWeightToFee")," struct"),Object(i.mdx)("p",null,"In ",Object(i.mdx)("inlineCode",{parentName:"p"},"runtime/src/libs.rs"),", create the struct called ",Object(i.mdx)("inlineCode",{parentName:"p"},"LinearWeightToFee")," that implements ",Object(i.mdx)("inlineCode",{parentName:"p"},"WeightToFeePolynomial"),". It must return\na smallvec of ",Object(i.mdx)("inlineCode",{parentName:"p"},"WeightToFeeCoefficient")," integers:"),Object(i.mdx)("pre",null,Object(i.mdx)("code",{parentName:"pre",className:"language-rust"},"pub struct LinearWeightToFee<C>(sp_std::marker::PhantomData<C>);\n\nimpl<C> WeightToFeePolynomial for LinearWeightToFee<C>\nwhere\n    C: Get<Balance>,\n{\n    type Balance = Balance;\n\n    fn polynomial() -> WeightToFeeCoefficients<Self::Balance> {\n        let coefficient = WeightToFeeCoefficient {\n            coeff_integer: C::get(),\n            coeff_frac: Perbill::zero(),\n            negative: false,\n            degree: 1,\n        };\n\n        smallvec!(coefficient)\n    }\n}\n")),Object(i.mdx)("h3",{id:"2-configure-pallet_transaction_payment-in-your-runtime"},"2. Configure ",Object(i.mdx)("inlineCode",{parentName:"h3"},"pallet_transaction_payment")," in your runtime"),Object(i.mdx)("p",null,"Convert the dispatch weight\n",Object(i.mdx)("inlineCode",{parentName:"p"},"type WeightToFee")," to the chargeable fee ",Object(i.mdx)("inlineCode",{parentName:"p"},"LinearWeightToFee")," (replacing ",Object(i.mdx)("inlineCode",{parentName:"p"},"IdentityFee<Balance>;"),"):"),Object(i.mdx)("pre",null,Object(i.mdx)("code",{parentName:"pre",className:"language-rust"},"parameter_types! {\n    // Used with LinearWeightToFee conversion.\n    pub const FeeWeightRatio: u128 = 1_000;\n    // Establish the byte-fee. It is used in all configurations.\n    pub const TransactionByteFee: u128 = 1;\n}\n\nimpl pallet_transaction_payment::Config for Runtime {\n    type OnChargeTransaction = CurrencyAdapter<Balances, ()>;\n    type TransactionByteFee = TransactionByteFee;\n\n    // Convert dispatch weight to a chargeable fee.\n    type WeightToFee = LinearWeightToFee<FeeWeightRatio>;\n\n    type FeeMultiplierUpdate = ();\n}\n")),Object(i.mdx)("h2",{id:"examples"},"Examples"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("a",{parentName:"li",href:"https://github.com/paritytech/substrate/tree/master/frame/transaction-payment"},"transaction-payment-pallet")),Object(i.mdx)("li",{parentName:"ul"},"pallet-weights")),Object(i.mdx)("h2",{id:"related-material"},"Related material"),Object(i.mdx)("h4",{id:"how-to-guides"},"How-to guides"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("a",{parentName:"li",href:"./conditional-weight-struct"},"Conditional weighting struct")),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("a",{parentName:"li",href:"./linear-weight-struct"},"Linear weighting struct")),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("a",{parentName:"li",href:"./quadratic-weight-struct"},"Quadratic weighting struct"))),Object(i.mdx)("h4",{id:"knowledgebase"},"Knowledgebase"),Object(i.mdx)("h4",{id:"rust-docs"},"Rust docs"),Object(i.mdx)("ul",null,Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("p",{parentName:"li"},Object(i.mdx)("a",{parentName:"p",href:"https://substrate.dev/rustdocs/latest/frame_support/weights/type.WeightToFeeCoefficients.html"},Object(i.mdx)("inlineCode",{parentName:"a"},"WeightToFeeCoefficients")))),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("p",{parentName:"li"},Object(i.mdx)("a",{parentName:"p",href:"https://substrate.dev/rustdocs/latest/frame_support/weights/type.WeightToFeeCoefficient.html"},Object(i.mdx)("inlineCode",{parentName:"a"},"WeightToFeeCoefficient")))),Object(i.mdx)("li",{parentName:"ul"},Object(i.mdx)("p",{parentName:"li"},Object(i.mdx)("a",{parentName:"p",href:"https://crates.parity.io/frame_support/weights/trait.WeightToFeePolynomial.html"},Object(i.mdx)("inlineCode",{parentName:"a"},"WeightToFeePolynomial"))))))}m.isMDXComponent=!0}}]);