(window.webpackJsonp=window.webpackJsonp||[]).push([[21],{188:function(e,t,n){"use strict";n.r(t),n.d(t,"MDXContext",(function(){return c})),n.d(t,"MDXProvider",(function(){return u})),n.d(t,"mdx",(function(){return g})),n.d(t,"useMDXComponents",(function(){return p})),n.d(t,"withMDXComponents",(function(){return m}));var a=n(0),i=n.n(a);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(){return(o=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var a in n)Object.prototype.hasOwnProperty.call(n,a)&&(e[a]=n[a])}return e}).apply(this,arguments)}function s(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?s(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):s(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function d(e,t){if(null==e)return{};var n,a,i=function(e,t){if(null==e)return{};var n,a,i={},r=Object.keys(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||(i[n]=e[n]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(a=0;a<r.length;a++)n=r[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(i[n]=e[n])}return i}var c=i.a.createContext({}),m=function(e){return function(t){var n=p(t.components);return i.a.createElement(e,o({},t,{components:n}))}},p=function(e){var t=i.a.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},u=function(e){var t=p(e.components);return i.a.createElement(c.Provider,{value:t},e.children)},h={inlineCode:"code",wrapper:function(e){var t=e.children;return i.a.createElement(i.a.Fragment,{},t)}},b=i.a.forwardRef((function(e,t){var n=e.components,a=e.mdxType,r=e.originalType,o=e.parentName,s=d(e,["components","mdxType","originalType","parentName"]),c=p(n),m=a,u=c["".concat(o,".").concat(m)]||c[m]||h[m]||r;return n?i.a.createElement(u,l(l({ref:t},s),{},{components:n})):i.a.createElement(u,l({ref:t},s))}));function g(e,t){var n=arguments,a=t&&t.mdxType;if("string"==typeof e||a){var r=n.length,o=new Array(r);o[0]=b;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:a,o[1]=s;for(var d=2;d<r;d++)o[d]=n[d];return i.a.createElement.apply(null,o)}return i.a.createElement.apply(null,n)}b.displayName="MDXCreateElement"},54:function(e,t,n){"use strict";n.r(t),n.d(t,"frontMatter",(function(){return o})),n.d(t,"metadata",(function(){return s})),n.d(t,"toc",(function(){return l})),n.d(t,"default",(function(){return c}));var a=n(3),i=n(8),r=(n(0),n(188)),o={sidebar_position:3,keywords:"pallet design, intermediate, runtime"},s={unversionedId:"tutorials/Kitties/Part 1/create-kitties",id:"tutorials/Kitties/Part 1/create-kitties",isDocsHomePage:!1,title:"Uniqueness, custom types and storage maps",description:"_In this part of the tutorial, we'll build out the components of our pallet",source:"@site/docs/09-tutorials/01-Kitties/Part 1/create-kitties.md",sourceDirName:"09-tutorials/01-Kitties/Part 1",slug:"/tutorials/Kitties/Part 1/create-kitties",permalink:"/substrate-how-to-guides/docs/tutorials/Kitties/Part 1/create-kitties",editUrl:"https://github.com/substrate-developer-hub/substrate-how-to-guides/edit/main/docs/09-tutorials/01-Kitties/Part 1/create-kitties.md",version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3,keywords:"pallet design, intermediate, runtime"},sidebar:"tutorialSidebar",previous:{title:"Basic set-up",permalink:"/substrate-how-to-guides/docs/tutorials/Kitties/Part 1/basic-setup"},next:{title:"Dispatchables, Events and Errors",permalink:"/substrate-how-to-guides/docs/tutorials/Kitties/Part 1/dispatchables-and-events"}},l=[{value:"Overview",id:"overview",children:[]},{value:"Learning outcomes",id:"learning-outcomes",children:[]},{value:"Steps",id:"steps",children:[{value:"1. Kitty struct scaffolding",id:"1-kitty-struct-scaffolding",children:[]},{value:"2. Writing a custom type for <code>Gender</code>",id:"2-writing-a-custom-type-for-gender",children:[]},{value:"3. Implement on-chain randomness",id:"3-implement-on-chain-randomness",children:[]},{value:"4. Write remaining storage items",id:"4-write-remaining-storage-items",children:[]}]},{value:"Next steps",id:"next-steps",children:[]}],d={toc:l};function c(e){var t=e.components,n=Object(i.default)(e,["components"]);return Object(r.mdx)("wrapper",Object(a.default)({},d,n,{components:t,mdxType:"MDXLayout"}),Object(r.mdx)("p",null,Object(r.mdx)("em",{parentName:"p"},"In this part of the tutorial, we'll build out the components of our pallet\nneeded to manage the creation and ownership of our Kitties.")),Object(r.mdx)("h2",{id:"overview"},"Overview"),Object(r.mdx)("p",null,"This part of the tutorial dives into some pillar concepts for developing pallets with FRAME. Ontop of learning\nhow to use existing types and traits, you'll learn how create your own types like providing your pallet with\na Gender type.\nAt the end of this part, you will have implemented the 2 remaining storage items according to the logic outlined for the Substrate Kitty\napplication ",Object(r.mdx)("a",{parentName:"p",href:"../overview#what-were-building"},"in the overview of this tutorial"),"."),Object(r.mdx)("h2",{id:"learning-outcomes"},"Learning outcomes"),Object(r.mdx)("p",null,"\u27a1\ufe0f Writing a custom struct and using it in storage."),Object(r.mdx)("p",null,"\u27a1\ufe0f Creating a custom type and implementing it for your pallet's ",Object(r.mdx)("inlineCode",{parentName:"p"},"Config")," trait."),Object(r.mdx)("p",null,"\u27a1\ufe0f Using the Randomness trait in a helper function."),Object(r.mdx)("p",null,"\u27a1\ufe0f Adding ",Object(r.mdx)("inlineCode",{parentName:"p"},"StorageMap")," items to a pallet."),Object(r.mdx)("h2",{id:"steps"},"Steps"),Object(r.mdx)("h3",{id:"1-kitty-struct-scaffolding"},"1. Kitty struct scaffolding"),Object(r.mdx)("p",null,"We added additional comments to the code from Part I (in the ",Object(r.mdx)("inlineCode",{parentName:"p"},"/pallets/mykitties/src/lib.rs")," file) to better assist you with the action items in this part of the tutorial. To follow each step with ease,\nyou can just replace your code with the ",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/substrate-developer-hub/substrate-how-to-guides/blob/main/static/code/kitties-tutorial/02-create-kitties.rs"},"helper code")," provided below:"),Object(r.mdx)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.mdx)("div",{parentName:"div",className:"admonition-heading"},Object(r.mdx)("h5",{parentName:"div"},Object(r.mdx)("span",{parentName:"h5",className:"admonition-icon"},Object(r.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(r.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"note")),Object(r.mdx)("div",{parentName:"div",className:"admonition-content"},Object(r.mdx)("p",{parentName:"div"},'If you\'re feeling confident, you can use the code from the previous part and use\nthe comments marked as "TODO" to follow each step instead of\npasting in the helper file for this part.'))),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},'#![cfg_attr(not(feature = "std"), no_std)]\n\npub use pallet::*;\n\n#[frame_support::pallet]\npub mod pallet {\n  use frame_support::pallet_prelude::*;\n    use frame_system::pallet_prelude::*;\n    use frame_support::{\n        sp_runtime::traits::Hash,\n        traits::{ Randomness, Currency, tokens::ExistenceRequirement },\n        transactional\n    };\n    use sp_io::hashing::blake2_128;\n\n    #[cfg(feature = "std")]\n    use serde::{Deserialize, Serialize};\n\n    // ACTION #1: Write a Struct to hold Kitty information.\n    \n    // ACTION #2: Enum declaration for Gender.\n\n    // ACTION #3: Implementation to handle Gender type in Kitty struct.\n\n\n    #[pallet::pallet]\n    #[pallet::generate_store(trait Store)]\n    pub struct Pallet<T>(_);\n\n    /// Configure the pallet by specifying the parameters and types it depends on.\n    #[pallet::config]\n    pub trait Config: pallet_balances::Config + frame_system::Config {\n        /// Because this pallet emits events, it depends on the runtime\'s definition of an event.\n        type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;\n        \n        /// The Currency handler for the Kitties pallet.\n        type Currency: Currency<Self::AccountId>;\n\n        // ACTION #5: Specify the type for Randomness we want to specify for runtime.\n    }\n\n    // Errors.\n    #[pallet::error]\n    pub enum Error<T> {\n        // TODO Part III\n    }\n\n    // Events.\n    #[pallet::event]\n    #[pallet::metadata(T::AccountId = "AccountId")]\n    #[pallet::generate_deposit(pub(super) fn deposit_event)]\n    pub enum Event<T: Config> {\n        // TODO Part III\n    }\n\n    #[pallet::storage]\n    #[pallet::getter(fn all_kitties_count)]\n    pub(super) type AllKittiesCount<T: Config> = StorageValue<_, u64, ValueQuery>;\n    \n    // ACTION #6: Add Nonce storage item.\n\n    // ACTION #9: Remaining storage items.\n\n    // TODO Part IV: Our pallet\'s genesis configuration.\n\n    #[pallet::call]\n    impl<T: Config> Pallet<T> {\n        \n        // TODO Part III: create_kitty\n        \n        // TODO Part III: set_price\n        \n        // TODO Part III: transfer\n\n        // TODO Part III: buy_kitty\n        \n        // TODO Part III: breed_kitty\n    }\n\n    // ACTION #4: helper function for Kitty struct\n\n    impl<T: Config> Pallet<T> {\n        // TODO Part III: helper functions for dispatchable functions\n        \n        // ACTION #7: increment_nonce helper\n\n        // ACTION #8: random_hash helper\n\n        // TODO: mint, transfer_from\n        \n    }\n}\n')),Object(r.mdx)("h4",{id:"a-what-information-to-include"},"A. What information to include"),Object(r.mdx)("p",null,"Structs are a useful tool to help store data that have things in common.\nFor our purposes, our Kitty will carry multiple traits which we can store in a single struct\ninstead of using separate storage items. This comes in handy when trying to optimize\nfor storage reads and writes because our runtime will need to perform less read/writes to update\nmultiple values. Read more about storage best practices ",Object(r.mdx)("a",{parentName:"p",href:"https://substrate.dev/docs/en/knowledgebase/runtime/storage#best-practices"},"here"),". "),Object(r.mdx)("p",null,"Let's first go over what information a single Kitty will carry:"),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},Object(r.mdx)("inlineCode",{parentName:"strong"},"dna")),": the hash used to identify the DNA of a Kitty, which corresponds to its unique features.\nDNA is also used to breed new Kitties and to keep track of different Kitty generations."),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},Object(r.mdx)("inlineCode",{parentName:"strong"},"price")),": this is a balance that corresponds to the amount needed to buy a Kitty and\nset by its owner."),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},Object(r.mdx)("inlineCode",{parentName:"strong"},"gender")),": an enum that can be either ",Object(r.mdx)("inlineCode",{parentName:"li"},"Male")," or ",Object(r.mdx)("inlineCode",{parentName:"li"},"Female"),"."),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},Object(r.mdx)("inlineCode",{parentName:"strong"},"owner")),": an account ID designating a single owner.")),Object(r.mdx)("h4",{id:"b-sketching-out-the-types-held-by-our-struct"},"B. Sketching out the types held by our struct"),Object(r.mdx)("p",null,"Looking at the items of our struct from ",Object(r.mdx)("a",{parentName:"p",href:"/docs/Tutorials/Kitties/Part%201/create-kitties#a-what-information-to-include"},"step 1A"),", we can deduce the following types: "),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},Object(r.mdx)("inlineCode",{parentName:"strong"},"[u8; 16]"))," for ",Object(r.mdx)("inlineCode",{parentName:"li"},"dna")," (to use 16 bytes to represent a Kitty's DNA)"),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},Object(r.mdx)("inlineCode",{parentName:"strong"},"BalanceOf"))," for ",Object(r.mdx)("inlineCode",{parentName:"li"},"price")," (this is a custom type using FRAME's ",Object(r.mdx)("a",{parentName:"li",href:"https://substrate.dev/rustdocs/latest/frame_support/traits/tokens/currency/trait.Currency.html#associatedtype.Balance"},Object(r.mdx)("inlineCode",{parentName:"a"},"Currency")," trait"),")"),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},Object(r.mdx)("inlineCode",{parentName:"strong"},"Gender"))," for ",Object(r.mdx)("inlineCode",{parentName:"li"},"gender")," (we're going to need to create this!)")),Object(r.mdx)("p",null,"First, we'll need to add in our custom types for ",Object(r.mdx)("inlineCode",{parentName:"p"},"BalanceOf")," and ",Object(r.mdx)("inlineCode",{parentName:"p"},"AccountOf")," before we declare our struct. Replace ACTION #1 with the following snippet:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"type AccountOf<T> = <T as frame_system::Config>::AccountId;\ntype BalanceOf<T> =\n    <<T as Config>::Currency as Currency<<T as frame_system::Config>::AccountId>>::Balance;\n")),Object(r.mdx)("p",null,"Now, paste in the our Kitty struct:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"// Struct for holding Kitty information.\n#[derive(Clone, Encode, Decode, PartialEq)]\npub struct Kitty<T: Config> {\n    pub dna: [u8; 16],   \n    pub price: Option<BalanceOf<T>>,\n    pub gender: Gender,\n    pub owner: AccountOf<T>,\n}\n")),Object(r.mdx)("p",null,"Notice how we use the derive macro to include ",Object(r.mdx)("a",{parentName:"p",href:"https://substrate.dev/rustdocs/latest/sp_std/prelude/index.html#traits"},"various helper traits")," for using our struct.\nFor type ",Object(r.mdx)("inlineCode",{parentName:"p"},"Gender"),", we'll need to build out our own custom enum and helper functions. Now's a good time\nto do that."),Object(r.mdx)("h3",{id:"2-writing-a-custom-type-for-gender"},"2. Writing a custom type for ",Object(r.mdx)("inlineCode",{parentName:"h3"},"Gender")),Object(r.mdx)("p",null,"We've just created a struct that requires a custom type called ",Object(r.mdx)("inlineCode",{parentName:"p"},"Gender"),". This type will handle an enum defining our Kitty's gender. To create it, you'll build out the following parts:"),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},"An enum declaration"),", which specifies ",Object(r.mdx)("inlineCode",{parentName:"li"},"Male")," and ",Object(r.mdx)("inlineCode",{parentName:"li"},"Female")," values."),Object(r.mdx)("li",{parentName:"ul"},Object(r.mdx)("strong",{parentName:"li"},"A function to configure a defaut value"),", based on the enum.")),Object(r.mdx)("div",{className:"admonition admonition-info alert alert--info"},Object(r.mdx)("div",{parentName:"div",className:"admonition-heading"},Object(r.mdx)("h5",{parentName:"div"},Object(r.mdx)("span",{parentName:"h5",className:"admonition-icon"},Object(r.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(r.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M7 2.3c3.14 0 5.7 2.56 5.7 5.7s-2.56 5.7-5.7 5.7A5.71 5.71 0 0 1 1.3 8c0-3.14 2.56-5.7 5.7-5.7zM7 1C3.14 1 0 4.14 0 8s3.14 7 7 7 7-3.14 7-7-3.14-7-7-7zm1 3H6v5h2V4zm0 6H6v2h2v-2z"}))),"info")),Object(r.mdx)("div",{parentName:"div",className:"admonition-content"},Object(r.mdx)("p",{parentName:"div"},"Setting up our ",Object(r.mdx)("inlineCode",{parentName:"p"},"Gender")," enum using a function to configure its default value will allow us to derive a Kitty's gender by passing in the randomness\ncreated by each Kitty's DNA."))),Object(r.mdx)("h4",{id:"a-enums"},"A. Enums"),Object(r.mdx)("p",null,"Replace ACTION item #2 with the following enum declaration:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"#[derive(Encode, Decode, Debug, Clone, PartialEq)]\npub enum Gender {\n    Male,\n    Female,\n}\n")),Object(r.mdx)("p",null,"Notice the use of the ",Object(r.mdx)("a",{parentName:"p",href:"https://doc.rust-lang.org/reference/procedural-macros.html#derive-macros"},"derive macro")," which must precede the enum declaration. This wraps our enum in the data structures it will need to interface with other types in our runtime."),Object(r.mdx)("p",null,"Then, we need a function to define a default implementation for our enum by using Rust's ",Object(r.mdx)("a",{parentName:"p",href:"https://doc.rust-lang.org/std/default/trait.Default.html"},Object(r.mdx)("inlineCode",{parentName:"a"},"Default")," trait"),"."),Object(r.mdx)("p",null,"Replace the line containing ACTION #3 with: "),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"impl Default for Gender {\n    fn default() -> Self {\n        Gender::Male\n    }\n}\n")),Object(r.mdx)("p",null,"\ud83d\udca1 ",Object(r.mdx)("strong",{parentName:"p"},"This is like saying:")," let's give our enum a special trait that allows us to initialize it to a specific value."),Object(r.mdx)("p",null,"Great, we now know how to create a custom struct and specify its default value. But what about providing\na way for a Kitty struct to be ",Object(r.mdx)("em",{parentName:"p"},"assigned")," a gender value? For that we need to learn one more thing."),Object(r.mdx)("h4",{id:"b-configuring-functions-for-our-kitty-struct"},"B. Configuring functions for our Kitty struct"),Object(r.mdx)("p",null,"Configuring a struct is useful in order to pre-define a value in our struct. For example, when setting\na value in relation to what another function returns. In our case we have a similar situation where\nwe need to configure our Kitty struct in such a way that sets ",Object(r.mdx)("inlineCode",{parentName:"p"},"Gender")," according to a Kitty's DNA. "),Object(r.mdx)("p",null,"We'll only be using this function when we get to ",Object(r.mdx)("a",{parentName:"p",href:"/docs/tutorials/Kitties/Part%201/dispatchables-and-events#2-write-the-create_kitty-dispatchable"},"creating Kitties"),". Regardless, learn how to write it now and get it out of the way."),Object(r.mdx)("p",null,"When you're implementing the configuration trait for a struct inside a FRAME pallet, you're doing the\nsame type of thing as implementing some trait for an enum except you're implementing the generic\nconfiguration trait, ",Object(r.mdx)("inlineCode",{parentName:"p"},"Config"),". In our case we'll create a public function called ",Object(r.mdx)("inlineCode",{parentName:"p"},"gen_gender")," that returns the ",Object(r.mdx)("inlineCode",{parentName:"p"},"Gender")," type\nand uses a random function to choose between ",Object(r.mdx)("inlineCode",{parentName:"p"},"Gender")," enum values. "),Object(r.mdx)("p",null,"Replace ACTION #4 with the following code snippet:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},'fn gen_gender() -> Gender {\n    let random = T::KittyRandomness::random(&b"gender"[..]).0;\n    match random.as_ref()[0] % 2 {\n        0 => Gender::Male,\n        _ => Gender::Female,\n    }\n}\n')),Object(r.mdx)("p",null,"Now whenever ",Object(r.mdx)("inlineCode",{parentName:"p"},"gen_gender()")," is called inside our pallet, it will return a pseudo random enum value for ",Object(r.mdx)("inlineCode",{parentName:"p"},"Gender"),"."),Object(r.mdx)("h3",{id:"3-implement-on-chain-randomness"},"3. Implement on-chain randomness"),Object(r.mdx)("p",null,"If we want to be able to tell these Kitties apart, we need to start giving them unique properties!\nIn the previous step, we've made use of ",Object(r.mdx)("inlineCode",{parentName:"p"},"KittyRandomness")," which we haven't actually defined yet. Let's get to it."),Object(r.mdx)("p",null,"We'll be using the ",Object(r.mdx)("a",{parentName:"p",href:"https://substrate.dev/rustdocs/latest/frame_support/traits/trait.Randomness.html"},"Randomness trait")," from ",Object(r.mdx)("inlineCode",{parentName:"p"},"frame_support")," to do this. It will be able to generate a random seed which\nwe'll create unique Kitties with as well as breed new ones."),Object(r.mdx)("p",null,"In order to implement the ",Object(r.mdx)("inlineCode",{parentName:"p"},"Randomness")," trait for our runtime, we must:"),Object(r.mdx)("p",null,Object(r.mdx)("strong",{parentName:"p"},"A. Specify it in our pallet's configuration trait.")),Object(r.mdx)("p",null,"The ",Object(r.mdx)("inlineCode",{parentName:"p"},"Randomness")," trait from ",Object(r.mdx)("inlineCode",{parentName:"p"},"frame_support")," requires specifying it with a paramater to replace the ",Object(r.mdx)("inlineCode",{parentName:"p"},"Output")," and ",Object(r.mdx)("inlineCode",{parentName:"p"},"BlockNumber")," generics.\nTake a look at ",Object(r.mdx)("a",{parentName:"p",href:"https://substrate.dev/rustdocs/latest/frame_support/traits/trait.Randomness.html"},"the documentation")," and the source code implementation to understand how this works. For our purposes,\nwe want the output of functions using this trait to be ",Object(r.mdx)("a",{parentName:"p",href:"https://substrate.dev/rustdocs/latest/sp_core/struct.H256.html"},Object(r.mdx)("inlineCode",{parentName:"a"},"H256"))," which you'll notice should already be declared at the\ntop of your working codebase."),Object(r.mdx)("p",null,"Replace the ACTION #5 line with:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"type KittyRandomness: Randomness<Self::H256, Self::BlockNumber>;\n")),Object(r.mdx)("p",null,Object(r.mdx)("strong",{parentName:"p"},"B. Specify it for our runtime.")),Object(r.mdx)("p",null,"Given that we're adding a new type for the configuration of our pallet, we need to tell our runtime about its implementation.\nThis could come in handy if ever we wanted to change the algorithm that ",Object(r.mdx)("inlineCode",{parentName:"p"},"KittyRandomness")," is using, without needing to\nmodify where it's used inside our pallet."),Object(r.mdx)("p",null,"To showcase this point, we're going to implement ",Object(r.mdx)("inlineCode",{parentName:"p"},"KittyRandomness")," by assigning it to an instance of ",Object(r.mdx)("a",{parentName:"p",href:"https://substrate.dev/rustdocs/latest/pallet_randomness_collective_flip/index.html"},"FRAME's ",Object(r.mdx)("inlineCode",{parentName:"a"},"RandomnessCollectiveFlip")),".\nConveniently, the Node Template already has an instance of the ",Object(r.mdx)("inlineCode",{parentName:"p"},"RandomnessCollectiveFlip")," pallet.\nAll you need to do is ",Object(r.mdx)("strong",{parentName:"p"},"include the ",Object(r.mdx)("inlineCode",{parentName:"strong"},"KittyRandomness")," type for your runtime inside ",Object(r.mdx)("inlineCode",{parentName:"strong"},"runtime/src/lib.rs")),":"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"impl pallet_mykitties::Config for Runtime {\n    type Event = Event;\n    type KittyRandomness = RandomnessCollectiveFlip; // <-- ACTION: add this line.\n}\n")),Object(r.mdx)("div",{className:"admonition admonition-tip alert alert--success"},Object(r.mdx)("div",{parentName:"div",className:"admonition-heading"},Object(r.mdx)("h5",{parentName:"div"},Object(r.mdx)("span",{parentName:"h5",className:"admonition-icon"},Object(r.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(r.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),Object(r.mdx)("div",{parentName:"div",className:"admonition-content"},Object(r.mdx)("p",{parentName:"div"},"Check out this ",Object(r.mdx)("a",{parentName:"p",href:"/docs/pallet-design/randomness"},"how-to guide")," on implementing randomness in case you get stuck."))),Object(r.mdx)("h4",{id:"generating-random-dna"},"Generating random DNA"),Object(r.mdx)("p",null,"Generating DNA is similar to using randomness to randomly assign a gender type. The difference is that we'll be making use of ",Object(r.mdx)("inlineCode",{parentName:"p"},"blake2_128")," we imported in the previous part. Replace the ACTION #7 line with:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},'fn gen_dna() -> [u8; 16] {\n    let payload = (\n        T::KittyRandomness::random(&b"dna"[..]).0,\n        <frame_system::Pallet<T>>::block_number(),\n    );\n    payload.using_encoded(blake2_128)\n}\n')),Object(r.mdx)("h3",{id:"4-write-remaining-storage-items"},"4. Write remaining storage items"),Object(r.mdx)("h4",{id:"a-understanding-storage-item-logic"},"A. Understanding storage item logic"),Object(r.mdx)("p",null,"To easily track all of our kitties, we're going to standardize our logic to use a unique ID as the global key\nfor our storage items. This means that a single unique key will point to our Kitty object (i.e. the struct we previously declared)."),Object(r.mdx)("p",null,"In order for this to work, we need to make sure that the ID for a new Kitty is always unique.\nWe can do this with a new storage item ",Object(r.mdx)("inlineCode",{parentName:"p"},"Kitties")," which will be a mapping from an ID (Hash) to the Kitty object."),Object(r.mdx)("p",null,"With this object, we can easily check for collisions by simply checking whether this storage item already contains a mapping\nusing a particular ID. For example, from inside a dispatchable function we could check using:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},'ensure!(!<Kitties<T>>::exists(new_id), "This new id already exists");\n')),Object(r.mdx)("div",{className:"admonition admonition-tip alert alert--success"},Object(r.mdx)("div",{parentName:"div",className:"admonition-heading"},Object(r.mdx)("h5",{parentName:"div"},Object(r.mdx)("span",{parentName:"h5",className:"admonition-icon"},Object(r.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"12",height:"16",viewBox:"0 0 12 16"},Object(r.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.5 0C3.48 0 1 2.19 1 5c0 .92.55 2.25 1 3 1.34 2.25 1.78 2.78 2 4v1h5v-1c.22-1.22.66-1.75 2-4 .45-.75 1-2.08 1-3 0-2.81-2.48-5-5.5-5zm3.64 7.48c-.25.44-.47.8-.67 1.11-.86 1.41-1.25 2.06-1.45 3.23-.02.05-.02.11-.02.17H5c0-.06 0-.13-.02-.17-.2-1.17-.59-1.83-1.45-3.23-.2-.31-.42-.67-.67-1.11C2.44 6.78 2 5.65 2 5c0-2.2 2.02-4 4.5-4 1.22 0 2.36.42 3.22 1.19C10.55 2.94 11 3.94 11 5c0 .66-.44 1.78-.86 2.48zM4 14h5c-.23 1.14-1.3 2-2.5 2s-2.27-.86-2.5-2z"}))),"tip")),Object(r.mdx)("div",{parentName:"div",className:"admonition-content"},Object(r.mdx)("p",{parentName:"div"},"Our pallet's logic can best be understood\nby examining the storage items we'll be using.\nIn other words, ",Object(r.mdx)("strong",{parentName:"p"},"the way we define the conditions for reading and writing to our runtime's storage helps us breakdown the items we'll need to enable NFT capabilities"),". "))),Object(r.mdx)("p",null,"We care about state transitions and persistance around two main concepts our runtime needs to be made aware of:"),Object(r.mdx)("ol",null,Object(r.mdx)("li",{parentName:"ol"},"Unique assets, like currency or Kitties (this will be held by a storgae map called ",Object(r.mdx)("inlineCode",{parentName:"li"},"Kitties"),")"),Object(r.mdx)("li",{parentName:"ol"},"Ownership of those assets, like account IDs (this will be handled by ",Object(r.mdx)("inlineCode",{parentName:"li"},"KittyCnt")," and a new storage map called ",Object(r.mdx)("inlineCode",{parentName:"li"},"KittiesOwned"),")")),Object(r.mdx)("h4",{id:"b-using-a-storagemap"},"B. Using a ",Object(r.mdx)("inlineCode",{parentName:"h4"},"StorageMap")),Object(r.mdx)("p",null,"To create a storage instance for the Kitty struct,\nwe'll be using ",Object(r.mdx)("a",{parentName:"p",href:"https://substrate.dev/docs/en/knowledgebase/runtime/storage#storage-map"},Object(r.mdx)("inlineCode",{parentName:"a"},"StorageMap"))," ","\u2014"," a hash-map provided\nto us by FRAME. "),Object(r.mdx)("p",null,"Here's what the ",Object(r.mdx)("inlineCode",{parentName:"p"},"Kitties")," storage item looks like:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"#[pallet::storage]\n#[pallet::getter(fn kitty)]\npub(super) type Kitties<T: Config> = StorageMap<\n    _, \n    Twox64Concat, \n    T::Hash, \n    Kitty<T>\n    >;\n")),Object(r.mdx)("p",null,"Breaking it down, we declare the storage type and assign a ",Object(r.mdx)("inlineCode",{parentName:"p"},"StorageMap")," that takes:"),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},"The ",Object(r.mdx)("a",{parentName:"li",href:"https://substrate.dev/rustdocs/latest/frame_support/struct.Twox64Concat.html"},Object(r.mdx)("inlineCode",{parentName:"a"},"Twox64Concat"))," hashing algorithm."),Object(r.mdx)("li",{parentName:"ul"},"A key of type ",Object(r.mdx)("inlineCode",{parentName:"li"},"T::Hash"),"."),Object(r.mdx)("li",{parentName:"ul"},"A value of type ",Object(r.mdx)("inlineCode",{parentName:"li"},"Kitty<T>"),".")),Object(r.mdx)("p",null,"The ",Object(r.mdx)("inlineCode",{parentName:"p"},"KittiesOwned")," storage item is similar except that we'll be using a ",Object(r.mdx)("inlineCode",{parentName:"p"},"BoundedVec")," to keep track of some maximum number of Kitties we'll configure in ",Object(r.mdx)("inlineCode",{parentName:"p"},"runtime/src/lib.s"),"."),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"#[pallet::storage]\n#[pallet::getter(fn kitties_owned)]\npub(super) type Kitties<T: Config> = StorageMap<\n    _, \n    Twox64Concat, \n    T::AccountId, \n    BoundedVec<T::Hash, T::MaxKittyOwned>,\n    ValueQuery\n    >;\n")),Object(r.mdx)("p",null,"Your turn!\nCopy the two code snippets above to replace line ACTION #8. "),Object(r.mdx)("p",null,"Before we can check our pallet compiles, we need to add ",Object(r.mdx)("inlineCode",{parentName:"p"},"MaxKittyOwned"),", which is a pallet constant that we need to declare (similar to ",Object(r.mdx)("inlineCode",{parentName:"p"},"KittyRandomness")," in the previous steps). Replace ACTION #9 with:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"    #[pallet::constant]\n    type MaxKittyOwned: Get<u32>;\n")),Object(r.mdx)("p",null,"And add this type to ",Object(r.mdx)("inlineCode",{parentName:"p"},"runtime/src/lib.rs"),":"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"parameter_types! {              // <- add this macro \n    // One can own at most 9,999 Kitties\n    pub const MaxKittyOwned: u32 = 9999; \n    }\n\n/// Configure the pallet-kitties in pallets/kitties.\nimpl pallet_kitties::Config for Runtime {\n    type Event = Event;\n    type Currency = Balances;\n    type KittyRandomness = RandomnessCollectiveFlip;\n    type MaxKittyOwned = MaxKittyOwned; // <- add this line\n}\n")),Object(r.mdx)("p",null,"Assuming you've followed the above steps correctly, now's a good time to check that your pallet compiles:"),Object(r.mdx)("pre",null,Object(r.mdx)("code",{parentName:"pre",className:"language-rust"},"cargo build -p pallet-mykitties\n")),Object(r.mdx)("p",null,"Running into difficulties? Check your solution against the ",Object(r.mdx)("a",{parentName:"p",href:"https://github.com/substrate-developer-hub/substrate-how-to-guides/blob/main/static/code/kitties-tutorial/03-dispatchables-and-events.rs"},"completed helper code")," for this part of the tutorial."),Object(r.mdx)("div",{className:"admonition admonition-note alert alert--secondary"},Object(r.mdx)("div",{parentName:"div",className:"admonition-heading"},Object(r.mdx)("h5",{parentName:"div"},Object(r.mdx)("span",{parentName:"h5",className:"admonition-icon"},Object(r.mdx)("svg",{parentName:"span",xmlns:"http://www.w3.org/2000/svg",width:"14",height:"16",viewBox:"0 0 14 16"},Object(r.mdx)("path",{parentName:"svg",fillRule:"evenodd",d:"M6.3 5.69a.942.942 0 0 1-.28-.7c0-.28.09-.52.28-.7.19-.18.42-.28.7-.28.28 0 .52.09.7.28.18.19.28.42.28.7 0 .28-.09.52-.28.7a1 1 0 0 1-.7.3c-.28 0-.52-.11-.7-.3zM8 7.99c-.02-.25-.11-.48-.31-.69-.2-.19-.42-.3-.69-.31H6c-.27.02-.48.13-.69.31-.2.2-.3.44-.31.69h1v3c.02.27.11.5.31.69.2.2.42.31.69.31h1c.27 0 .48-.11.69-.31.2-.19.3-.42.31-.69H8V7.98v.01zM7 2.3c-3.14 0-5.7 2.54-5.7 5.68 0 3.14 2.56 5.7 5.7 5.7s5.7-2.55 5.7-5.7c0-3.15-2.56-5.69-5.7-5.69v.01zM7 .98c3.86 0 7 3.14 7 7s-3.14 7-7 7-7-3.12-7-7 3.14-7 7-7z"}))),"Congratulations!")),Object(r.mdx)("div",{parentName:"div",className:"admonition-content"},Object(r.mdx)("p",{parentName:"div"},"If you've made it this far, you now have the foundations for your pallet to\nhandle the creation and changes in ownership of your Kitties! In this part of the tutorial, we've learnt:"),Object(r.mdx)("ul",{parentName:"div"},Object(r.mdx)("li",{parentName:"ul"},"How to write a struct and use it in a ",Object(r.mdx)("inlineCode",{parentName:"li"},"StorageMap"),"."),Object(r.mdx)("li",{parentName:"ul"},"How to implement a custom type."),Object(r.mdx)("li",{parentName:"ul"},"How to set a default enum value for a custom type."),Object(r.mdx)("li",{parentName:"ul"},"How to create a function to set a value for that custom type."),Object(r.mdx)("li",{parentName:"ul"},"How to implement the Randomness trait to write a function that generates randomness using a nonce."),Object(r.mdx)("li",{parentName:"ul"},"How to write ",Object(r.mdx)("inlineCode",{parentName:"li"},"StorageMap")," storage items.")))),Object(r.mdx)("h2",{id:"next-steps"},"Next steps"),Object(r.mdx)("ul",null,Object(r.mdx)("li",{parentName:"ul"},"Create a dispatchable function that mints a new Kitty"),Object(r.mdx)("li",{parentName:"ul"},"Create a helper function to handle storage updates"),Object(r.mdx)("li",{parentName:"ul"},"Implement Errors and Events")))}c.isMDXComponent=!0}}]);